#!/usr/bin/env ruby
require 'rubygems'
require 'hpricot'
require 'mechanize'
require 'yaml'
require 'colorize'
require 'json'

class Jenkins
  attr_accessor :config

  def self.symbolize_keys m
    n = {}
    m.each do |k,v|
      n[k.to_sym] = v.class == Hash ? Jenkins.symbolize_keys(v) : v
    end
    n
  end

  def initialize
    @config ||= {}
    config_file = "#{ENV['HOME']}/.jenkins-cli.yml"
    if File.exist? config_file
      @config = @config.merge Jenkins.symbolize_keys(YAML.load_file(config_file))[:jenkins]
      #puts "config: #{@config.inspect}"
    else
      puts "WARNING: no config file: #{config_file}"
    end
    @ua = Mechanize.new
    if @config[:htauth]
      @ua.add_auth(@config[:base_url],@config[:htauth][:user],@config[:htauth][:pass])
    end
    super
  end

  def make_url url
    "#{@config[:base_url]}#{url}"
  end

  def raw_get url, query_params = {}
    @ua.get make_url(url), query_params
  end

  def raw_post url, data, headers={}
    headers = {"Content-Type"=>"application/x-www-form-urlencoded; charset=UTF-8"}.merge(headers)
    url = make_url(url)
    #puts "posting to: #{url}"
    #puts "   headers: #{headers.inspect}"
    @ua.post(url, data, headers)
  end

  def command_line_arguments
    # super << []
    super
  end

  def last_successful_build_info row
    info = {}
    last_success_info = (row/"td").search("a[@href$='lastSuccessfulBuild/']").first
    if last_success_info.nil?
      return info
    else
      last_success_info = last_success_info.parent
      info[:time] = last_success_info.get_attribute('data')
      info[:ago]  = last_success_info.inner_html.split(/\s{2,}/)[1]
      info[:build] = last_success_info.search("a").first.inner_html
      return info
    end
  end
  
  def last_failed_build_info row
    info = {}
    last_failed_info = (row/"td").search("a[@href$='lastFailedBuild/']").first
    if last_failed_info.nil?
      return info
    else
      last_failed_info = last_failed_info.parent
      info[:time] = last_failed_info.get_attribute('data')
      info[:ago]  = last_failed_info.inner_html.split(/\s{2,}/)[1]
      info[:build] = last_failed_info.search("a").first.inner_html
      return info
    end
  end

  def detailed_projects_list
    if @detailed_projects_list.nil?
      @detailed_projects_list = []
      resp = raw_get "/"
      doc = Hpricot(resp.body)
      (doc/"table#projectstatus"/"tr")[1..-1].each do |row|
        rdoc = Hpricot(row.to_s)
        job_names = (rdoc/"a[@href^='job']")
        next if job_names.empty?
        job_name = job_names.first.to_s.scan(/job\/([^\/]+)\//).first.first
        status = (rdoc/"img").first.to_s.scan(/tooltip=\"([^"]+)\"/).first.first
        job_info = {:name => job_name, 
                    :status => status, 
                    :last_success => last_successful_build_info(rdoc),
                    :last_failure => last_failed_build_info(rdoc)
                    }
        @detailed_projects_list << job_info
      end
    end
    @detailed_projects_list
  end

  def projects_list
    if @projects_list.nil?
      @projects_list = []
      resp = raw_get "/"
      doc = Hpricot(resp.body)
      (doc/"table#projectstatus"/"a[@href^='job']").each do |link|
        job_name = link[:href].scan(/job\/([^\/]+)\//).first.first
        @projects_list << job_name
      end
      @projects_list = @projects_list.uniq.sort
    end

    @projects_list
  end

  def cmd_ls
    detailed_projects_list.each do |pinfo|
      status = pinfo[:status]
      succeeded = status == "Success"
      if status == "Success"
        status = status.green
      elsif status == "In progress"
        status = status.blue
      else
        status = status.red
      end
      output_cmd = succeeded ? "" : "# jenkins output #{pinfo[:name]}".yellow
      puts "#{pinfo[:name]}\t#{status}\t#{output_cmd}"
    end
  end
  
  def cmd_la
    detailed_projects_list.each do |pinfo|
      status = pinfo[:status]
      succeeded = status == "Success"
      if status == "Success"
        status = status.green
      elsif status == "In progress"
        status = status.blue
      else
        status = status.red
      end

      if pinfo[:last_success].empty?
        last_build_success = "  Last Success: N/A".yellow
      else
        last_build_success = "  Last Success: #{pinfo[:last_success][:ago]} ago, build #{pinfo[:last_success][:build]}".yellow
      end

      if pinfo[:last_failure].empty?
        last_build_failure = "  Last Failure: N/A".yellow
      else
        last_build_failure = "  Last Failure: #{pinfo[:last_failure][:ago]} ago, build #{pinfo[:last_failure][:build]}".yellow
      end
      
      output_cmd = succeeded ? "" : "# jenkins output #{pinfo[:name]}".yellow
      puts "#{pinfo[:name]}\t#{status}\n#{last_build_success}\n#{last_build_failure}"
    end
  end

  def assert_project! project
    unless projects_list.member? project
      puts "Error: project does not exist #{project.inspect}.  Try one of: #{@projects_list.join(" ")}"
      exit 1
    end
    true
  end

  def cmd_build *args
    watch, project = *args
    if watch == '-w' # watch
      watch, project = true, project
    else
      watch, project = false, watch
    end

    if project.nil? || project.empty?
      project = load_job_config["name"]
    end

    assert_project! project
    last_id = latest_build_id project
    puts "triggering: #{project}"
    resp = raw_get "/job/#{project}/build?delay=0sec"

    if watch
      if last_id.nil?
        $stdout.puts "Sorry, can't automatically watch the initial build, try following it in a second..."
        return
      end

      # wait for the next job to start
      puts "Waiting for new build to start, last was: #{last_id}"
      while last_id == get_project_info(project)[:builds].first[:number]
        print '.'
        sleep 0.5
        $stdout.flush
      end
      cmd_tail "-f", project
    end
  end

  def get_project_info project
    assert_project! project
    proj_info = {:name => project, :builds => []}
    resp = raw_get "/job/#{project}/"
    doc = Hpricot(resp.body)
    (doc/"table#buildHistory"/"tr.build-row").each do |row|
      next if (row/"img").first.nil?
      status = (row/"img").first[:tooltip]
      next if status.nil?
      link = (row/"a.tip").first
      status = status.split(/\s+/).first
      build_id = link[:href].scan(/\/(\d+)\/$/).first
      proj_info[:builds] << {:number => build_id, :status => status}
    end
    proj_info
  end

  def cmd_show project
    get_project_info(project)[:builds].each do |build|
      puts "#{build[:number]} #{build[:status]}"
    end
  end

  def latest_build_id project
    info = get_project_info(project)
    if info[:builds] && info[:builds].first
      info[:builds].first[:number]
    else
      nil
    end
  end

  # cat output of a job
  def cmd_output project=nil, build=nil
    if project.nil? || project.empty?
      project = load_job_config["name"]
    end

    build = latest_build_id(project)
    puts "get me #{project}/#{build}"
    resp = raw_get "/job/#{project}/#{build}/consoleText"
    puts resp.body
  end


  def cmd_tail *args
    follow, project = *args
    if follow == "-f"
      follow, project = true, project
    else
      follow, project = false, follow
    end

    if project.nil? || project.empty?
      project = load_job_config["name"]
    end

    build = latest_build_id(project)
    last = ""
    start = 0
    while true
      resp = raw_post "/job/#{project}/#{build}/logText/progressiveHtml", {:start => start}
      start = resp.header["x-text-size"]
      #$stderr.puts "new start=#{start}"
      last = resp.body
      print last
      break unless follow
      break unless resp.header["x-more-data"] == "true"
    end
  end

  def git_url
    if File.exist? ".git"
      return `grep url .git/config | head -n 1 |cut -f2 -d=`.chomp.strip
    end

    if File.exist? "../.git"
      return `grep url ../.git/config | head -n 1 |cut -f2 -d=`.chomp.strip
    end

    raise "Sorry, couldn't find a .git directory for the git_url, you'll have to create the config file yourself."
  end

  def load_job_config config_file=".jenkins-config.json"
    if !File.exist? config_file
      File.open(config_file, "w") do |f|
        f.write <<-END
{
  "name":           "#{File.basename(Dir.pwd)}",
  "builds_to_keep": "2",
  "git_url":        "#{git_url}",
  "build_command":  "bash bin/jenkins-build.sh",
  "email":          "#{@config[:email] || 'build@your-company.com'}"
}
        END
      end
      $stdout.puts "It looks like there was no #{config_file} here, so I made one for you:"
      $stdout.puts File.read(config_file)
      $stdout.puts "Please update it and run this command again."
      exit 1
    end
    content = File.read(config_file)
    config  = JSON.parse(content)
  end

  def cmd_new_job config_file=".jenkins-config.json"
    config  = load_job_config config_file

    create_params = {
      "name"   => config["name"],
      "mode"   => "hudson.model.FreeStyleProject",
      "Submit" => "OK",

      "json" => {
        "name"   => config["name"],
        "mode"   => "hudson.model.FreeStyleProject",
        "from"   => "",
        "Submit" => "OK"
      }.to_json
      }

    raw_post "/view/All/createItem", create_params, 'Content-Type' => 'application/x-www-form-urlencoded'
    cmd_configure_job config_file
  end

  def cmd_configure_job config_file=".jenkins-config.json"
    config  = load_job_config config_file

    params = {
      "json" => {
        "name" => config["name"],
        "description" => config["description"] || "Build: #{config["name"]}",
        "logrotate" => {
          "logrotate_days" => "",
          "logrotate_nums" => (config["builds_to_keep"] or "2"),
          "logrotate_artifact_days" => "",
          "logrotate_artifact_nums" => ""
        },
        "properties" => {
          "stapler-class-bag" => "true",
          "hudson-model-ParametersDefinitionProperty" => {}
        },
        "displayNameOrNull" => "",
        "scm" => {
          "value" => "1",
          "userRemoteConfigs" => {
            "url" =>  config["git_url"],
            "name" => "",
            "refspec" => ""
          },
          "branches" => {
            "name" => ""
          },
          "includedRegions" => "",
          "excludedRegions" => "",
          "excludedUsers" => "",
          "localBranch" => "",
          "relativeTargetDir" => "",
          "reference" => "",
          "scmName" => "",
          "gitConfigName" => "",
          "gitConfigEmail" => "",
          "pruneBranches" => false,
          "skipTag" => false,
          "clean" => false,
          "remotePoll" => false,
          "disableSubmodules" => false,
          "recursiveSubmodules" => false,
          "authorOrCommitter" => false,
          "wipeOutWorkspace" => false,
          "ignoreNotifyCommit" => false,
          "useShallowClone" => false,
          "" => ["hudson.plugins.git.util.DefaultBuildChooser", "auto"],
          "buildChooser" => {
            "stapler-class" => "hudson.plugins.git.util.DefaultBuildChooser"
          },
          "gitTool" => "Default"
        },
        "builder" => {
          "command" => (config["build_command"] or raise("You must supply a build_command")),
          "stapler-class" => "hudson.tasks.Shell",
          "kind" => "hudson.tasks.Shell"
        },
        "publisher" => {
          "mailer_recipients" => (config["email"] or raise("You must supply an email for build failures")),
          "mailer_notifyEveryUnstableBuild" => true,
          "mailer_sendToIndividuals" => false,
          "stapler-class" => "hudson.tasks.Mailer",
          "kind" => "hudson.tasks.Mailer"
        },
        "core:apply" => "true"
      }.to_json,
      "logrotate" => "on",
      "logrotate_nums" => (config["builds_to_keep"] or "2"),
      "scm"            => "1",
      "_.url"          => config["git_url"],
      "mailer_recipients" => config["email"],
      "description"       => (config["description"] or "Build: #{config["name"]}")
    }

    raw_post "/job/#{config["name"]}/configSubmit", params, 'Content-Type' => 'application/x-www-form-urlencoded'
  end

  def run
    if ARGV.empty?
      available = self.methods.map {|m| m.to_s}.select {|m| m.start_with? "cmd_"}.map {|m| m.sub(/cmd_/,'') }
      puts "You must supply a command: one of: #{available.join ", "}"
      exit 1
    end
    cmd = ("cmd_" + ARGV.shift.to_s.gsub('-','_')).to_sym
    unless self.respond_to? cmd
      raise "Error: command not recognized: #{cmd}"
    end

    self.send cmd, *ARGV
  end
end

Jenkins.new.run
